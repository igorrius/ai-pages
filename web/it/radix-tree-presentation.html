<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Radix Tree - Interactive Presentation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }

        .header h1 {
            font-size: 3em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .content {
            padding: 40px;
        }

        .section {
            margin-bottom: 50px;
            opacity: 0;
            transform: translateY(20px);
            animation: fadeInUp 0.6s ease forwards;
        }

        .section:nth-child(1) { animation-delay: 0.1s; }
        .section:nth-child(2) { animation-delay: 0.2s; }
        .section:nth-child(3) { animation-delay: 0.3s; }
        .section:nth-child(4) { animation-delay: 0.4s; }
        .section:nth-child(5) { animation-delay: 0.5s; }

        @keyframes fadeInUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h2 {
            color: #667eea;
            font-size: 2em;
            margin-bottom: 20px;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        h3 {
            color: #764ba2;
            font-size: 1.5em;
            margin: 20px 0 10px 0;
        }

        p {
            line-height: 1.8;
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        .highlight {
            background: #f0f4ff;
            padding: 20px;
            border-left: 4px solid #667eea;
            border-radius: 5px;
            margin: 20px 0;
        }

        .tree-container {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 30px;
            margin: 20px 0;
            text-align: center;
            overflow-x: auto;
        }

        .tree-node {
            display: inline-block;
            background: white;
            border: 2px solid #667eea;
            border-radius: 10px;
            padding: 15px 20px;
            margin: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            font-family: 'Courier New', monospace;
            font-weight: bold;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            cursor: pointer;
        }

        .tree-node:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.2);
        }

        .tree-node.highlighted {
            background: #667eea;
            color: white;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .interactive-demo {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 30px;
            margin: 20px 0;
        }

        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        input[type="text"] {
            flex: 1;
            min-width: 200px;
            padding: 12px 20px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s ease;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
        }

        button {
            padding: 12px 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        .svg-container {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            min-height: 400px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        svg {
            max-width: 100%;
            height: auto;
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .comparison-table th {
            background: #667eea;
            color: white;
            padding: 15px;
            text-align: left;
            font-size: 1.1em;
        }

        .comparison-table td {
            padding: 15px;
            border-bottom: 1px solid #ddd;
        }

        .comparison-table tr:hover {
            background: #f8f9fa;
        }

        .code-block {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 10px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
        }

        .code-block code {
            font-size: 0.95em;
            line-height: 1.8;
            white-space: pre;
            display: block;
        }

        .code-block pre {
            margin: 0;
            white-space: pre;
            overflow-x: auto;
        }

        .keyword { color: #ff79c6; }
        .string { color: #50fa7b; }
        .comment { color: #6272a4; }
        .function { color: #8be9fd; }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .stat-card h3 {
            color: white;
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .stat-card p {
            font-size: 1em;
            opacity: 0.9;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2em;
            }

            .content {
                padding: 20px;
            }

            h2 {
                font-size: 1.5em;
            }

            .input-group {
                flex-direction: column;
            }

            input[type="text"] {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üå≥ Radix Tree</h1>
            <p>A Space-Optimized Trie Data Structure</p>
        </div>

        <div class="content">
            <div class="section">
                <h2>üìö What is a Radix Tree?</h2>
                <p>A <strong>Radix Tree</strong> (also known as a Patricia Trie or Compact Prefix Tree) is a space-optimized trie data structure where nodes with a single child are merged with their parent. This results in edges that can contain strings rather than just single characters.</p>
                
                <div class="highlight">
                    <h3>Key Characteristics:</h3>
                    <p>‚úì Nodes are merged when they have only one child<br>
                    ‚úì Edges can represent entire strings, not just characters<br>
                    ‚úì More space-efficient than standard tries<br>
                    ‚úì Optimal for storing strings with common prefixes</p>
                </div>

                <div class="stats">
                    <div class="stat-card">
                        <h3>O(k)</h3>
                        <p>Search Time</p>
                    </div>
                    <div class="stat-card">
                        <h3>O(k)</h3>
                        <p>Insert Time</p>
                    </div>
                    <div class="stat-card">
                        <h3>O(n)</h3>
                        <p>Space Complexity</p>
                    </div>
                </div>
            </div>

            <div class="section">
                <h2>üîç Trie vs Radix Tree</h2>
                <p>Let's visualize the difference between a standard Trie and a Radix Tree using the words: <strong>test, toaster, toasting, slow, slower</strong></p>

                <div class="tree-container">
                    <h3>Standard Trie (More Nodes)</h3>
                    <svg id="trieVisualization" width="800" height="300"></svg>
                </div>

                <div class="tree-container">
                    <h3>Radix Tree (Compressed)</h3>
                    <svg id="radixVisualization" width="800" height="300"></svg>
                </div>

                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>Standard Trie</th>
                            <th>Radix Tree</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Node Storage</strong></td>
                            <td>One character per edge</td>
                            <td>String of characters per edge</td>
                        </tr>
                        <tr>
                            <td><strong>Space Efficiency</strong></td>
                            <td>Lower (many single-child nodes)</td>
                            <td>Higher (compressed paths)</td>
                        </tr>
                        <tr>
                            <td><strong>Nodes for "test"</strong></td>
                            <td>4 nodes (t‚Üíe‚Üís‚Üít)</td>
                            <td>1 node ("test")</td>
                        </tr>
                        <tr>
                            <td><strong>Best Use Case</strong></td>
                            <td>Many short words with shared prefixes</td>
                            <td>Long strings with few common prefixes</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="section">
                <h2>üéÆ Interactive Demo</h2>
                <div class="interactive-demo">
                    <p>Add words to build your own Radix Tree and watch it grow!</p>
                    
                    <div class="input-group">
                        <input type="text" id="wordInput" placeholder="Enter a word (e.g., 'romane', 'romanus')">
                        <button onclick="addWord()">Add Word</button>
                        <button onclick="searchWord()">Search</button>
                        <button onclick="clearTree()">Clear Tree</button>
                    </div>

                    <div id="output" style="margin: 20px 0; padding: 15px; background: white; border-radius: 8px; min-height: 50px;"></div>

                    <div class="svg-container">
                        <svg id="interactiveTree" width="900" height="500"></svg>
                    </div>
                </div>
            </div>

            <div class="section">
                <h2>üíª Implementation Examples</h2>
                
                <h3>JavaScript Implementation</h3>
                <p>Here's a simple implementation of a Radix Tree in JavaScript:</p>

                <div class="code-block">
                    <pre><code><span class="keyword">class</span> <span class="function">RadixNode</span> {
    <span class="function">constructor</span>() {
        <span class="keyword">this</span>.children = {};
        <span class="keyword">this</span>.isEndOfWord = <span class="keyword">false</span>;
    }
}

<span class="keyword">class</span> <span class="function">RadixTree</span> {
    <span class="function">constructor</span>() {
        <span class="keyword">this</span>.root = <span class="keyword">new</span> RadixNode();
    }

    <span class="function">insert</span>(word) {
        <span class="keyword">let</span> node = <span class="keyword">this</span>.root;
        <span class="keyword">let</span> i = 0;

        <span class="keyword">while</span> (i < word.length) {
            <span class="keyword">let</span> found = <span class="keyword">false</span>;
            
            <span class="comment">// Check existing edges</span>
            <span class="keyword">for</span> (<span class="keyword">let</span> edge <span class="keyword">in</span> node.children) {
                <span class="keyword">let</span> j = 0;
                <span class="keyword">while</span> (j < edge.length && i + j < word.length && 
                       edge[j] === word[i + j]) {
                    j++;
                }

                <span class="keyword">if</span> (j > 0) {
                    <span class="comment">// Split or traverse</span>
                    found = <span class="keyword">true</span>;
                    <span class="comment">// ... split logic here ...</span>
                }
            }

            <span class="keyword">if</span> (!found) {
                <span class="comment">// Create new edge</span>
                node.children[word.substring(i)] = <span class="keyword">new</span> RadixNode();
                node.children[word.substring(i)].isEndOfWord = <span class="keyword">true</span>;
                <span class="keyword">return</span>;
            }
        }
    }

    <span class="function">search</span>(word) {
        <span class="comment">// Search implementation...</span>
    }
}</code></pre>
                </div>

                <h3>Go Implementation</h3>
                <p>Complete Radix Tree implementation in Go with insert, search, delete, and prefix operations:</p>

                <div class="code-block">
                    <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"strings"</span>
)

<span class="comment">// RadixNode represents a node in the radix tree</span>
<span class="keyword">type</span> <span class="function">RadixNode</span> <span class="keyword">struct</span> {
    children    <span class="keyword">map</span>[<span class="keyword">string</span>]*RadixNode
    isEndOfWord <span class="keyword">bool</span>
    value       <span class="keyword">interface</span>{}  <span class="comment">// Optional: store associated data</span>
}

<span class="comment">// RadixTree is the main tree structure</span>
<span class="keyword">type</span> <span class="function">RadixTree</span> <span class="keyword">struct</span> {
    root *RadixNode
    size <span class="keyword">int</span>
}

<span class="comment">// NewRadixTree creates a new radix tree</span>
<span class="keyword">func</span> <span class="function">NewRadixTree</span>() *RadixTree {
    <span class="keyword">return</span> &RadixTree{
        root: &RadixNode{
            children: <span class="function">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*RadixNode),
        },
        size: 0,
    }
}

<span class="comment">// getCommonPrefix finds the longest common prefix</span>
<span class="keyword">func</span> <span class="function">getCommonPrefix</span>(s1, s2 <span class="keyword">string</span>) <span class="keyword">string</span> {
    minLen := <span class="function">len</span>(s1)
    <span class="keyword">if</span> <span class="function">len</span>(s2) < minLen {
        minLen = <span class="function">len</span>(s2)
    }
    
    <span class="keyword">for</span> i := 0; i < minLen; i++ {
        <span class="keyword">if</span> s1[i] != s2[i] {
            <span class="keyword">return</span> s1[:i]
        }
    }
    <span class="keyword">return</span> s1[:minLen]
}

<span class="comment">// Insert adds a word to the radix tree</span>
<span class="keyword">func</span> (t *RadixTree) <span class="function">Insert</span>(word <span class="keyword">string</span>, value <span class="keyword">interface</span>{}) {
    <span class="keyword">if</span> word == <span class="string">""</span> {
        <span class="keyword">return</span>
    }
    
    <span class="keyword">if</span> t.<span class="function">insertHelper</span>(t.root, word, value) {
        t.size++
    }
}

<span class="keyword">func</span> (t *RadixTree) <span class="function">insertHelper</span>(node *RadixNode, word <span class="keyword">string</span>, value <span class="keyword">interface</span>{}) <span class="keyword">bool</span> {
    <span class="keyword">if</span> word == <span class="string">""</span> {
        <span class="keyword">if</span> !node.isEndOfWord {
            node.isEndOfWord = <span class="keyword">true</span>
            node.value = value
            <span class="keyword">return</span> <span class="keyword">true</span>
        }
        <span class="keyword">return</span> <span class="keyword">false</span>
    }

    <span class="comment">// Try to find matching edge</span>
    <span class="keyword">for</span> edge, child := <span class="keyword">range</span> node.children {
        commonPrefix := <span class="function">getCommonPrefix</span>(edge, word)
        
        <span class="keyword">if</span> commonPrefix == <span class="string">""</span> {
            <span class="keyword">continue</span>
        }

        <span class="comment">// Case 1: Perfect match, continue with remaining word</span>
        <span class="keyword">if</span> commonPrefix == edge {
            remainingWord := word[<span class="function">len</span>(edge):]
            <span class="keyword">return</span> t.<span class="function">insertHelper</span>(child, remainingWord, value)
        }

        <span class="comment">// Case 2: Need to split the edge</span>
        <span class="keyword">delete</span>(node.children, edge)
        
        <span class="comment">// Create intermediate node</span>
        splitNode := &RadixNode{
            children: <span class="function">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*RadixNode),
        }
        node.children[commonPrefix] = splitNode

        <span class="comment">// Add the old child with remaining edge</span>
        remainingEdge := edge[<span class="function">len</span>(commonPrefix):]
        <span class="keyword">if</span> remainingEdge != <span class="string">""</span> {
            splitNode.children[remainingEdge] = child
        }

        <span class="comment">// Add new word path</span>
        remainingWord := word[<span class="function">len</span>(commonPrefix):]
        <span class="keyword">if</span> remainingWord == <span class="string">""</span> {
            splitNode.isEndOfWord = <span class="keyword">true</span>
            splitNode.value = value
        } <span class="keyword">else</span> {
            newNode := &RadixNode{
                children:    <span class="function">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*RadixNode),
                isEndOfWord: <span class="keyword">true</span>,
                value:       value,
            }
            splitNode.children[remainingWord] = newNode
        }
        <span class="keyword">return</span> <span class="keyword">true</span>
    }

    <span class="comment">// No matching edge found, create new one</span>
    newNode := &RadixNode{
        children:    <span class="function">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*RadixNode),
        isEndOfWord: <span class="keyword">true</span>,
        value:       value,
    }
    node.children[word] = newNode
    <span class="keyword">return</span> <span class="keyword">true</span>
}

<span class="comment">// Search looks for a word in the tree</span>
<span class="keyword">func</span> (t *RadixTree) <span class="function">Search</span>(word <span class="keyword">string</span>) (<span class="keyword">interface</span>{}, <span class="keyword">bool</span>) {
    node := t.root
    remaining := word

    <span class="keyword">for</span> remaining != <span class="string">""</span> {
        found := <span class="keyword">false</span>
        
        <span class="keyword">for</span> edge, child := <span class="keyword">range</span> node.children {
            <span class="keyword">if</span> strings.<span class="function">HasPrefix</span>(remaining, edge) {
                remaining = remaining[<span class="function">len</span>(edge):]
                node = child
                found = <span class="keyword">true</span>
                <span class="keyword">break</span>
            }
        }
        
        <span class="keyword">if</span> !found {
            <span class="keyword">return</span> <span class="keyword">nil</span>, <span class="keyword">false</span>
        }
    }

    <span class="keyword">return</span> node.value, node.isEndOfWord
}

<span class="comment">// StartsWith returns all words with given prefix</span>
<span class="keyword">func</span> (t *RadixTree) <span class="function">StartsWith</span>(prefix <span class="keyword">string</span>) []<span class="keyword">string</span> {
    results := []<span class="keyword">string</span>{}
    node := t.root
    remaining := prefix

    <span class="comment">// Navigate to the prefix node</span>
    <span class="keyword">for</span> remaining != <span class="string">""</span> {
        found := <span class="keyword">false</span>
        <span class="keyword">for</span> edge, child := <span class="keyword">range</span> node.children {
            <span class="keyword">if</span> strings.<span class="function">HasPrefix</span>(remaining, edge) {
                remaining = remaining[<span class="function">len</span>(edge):]
                node = child
                found = <span class="keyword">true</span>
                <span class="keyword">break</span>
            } <span class="keyword">else</span> <span class="keyword">if</span> strings.<span class="function">HasPrefix</span>(edge, remaining) {
                <span class="comment">// Partial match</span>
                node = child
                remaining = <span class="string">""</span>
                found = <span class="keyword">true</span>
                <span class="keyword">break</span>
            }
        }
        <span class="keyword">if</span> !found {
            <span class="keyword">return</span> results
        }
    }

    <span class="comment">// Collect all words from this node</span>
    t.<span class="function">collectWords</span>(node, prefix, &results)
    <span class="keyword">return</span> results
}

<span class="keyword">func</span> (t *RadixTree) <span class="function">collectWords</span>(node *RadixNode, prefix <span class="keyword">string</span>, results *[]<span class="keyword">string</span>) {
    <span class="keyword">if</span> node.isEndOfWord {
        *results = <span class="function">append</span>(*results, prefix)
    }

    <span class="keyword">for</span> edge, child := <span class="keyword">range</span> node.children {
        t.<span class="function">collectWords</span>(child, prefix+edge, results)
    }
}

<span class="comment">// Size returns the number of words in the tree</span>
<span class="keyword">func</span> (t *RadixTree) <span class="function">Size</span>() <span class="keyword">int</span> {
    <span class="keyword">return</span> t.size
}

<span class="comment">// Example usage</span>
<span class="keyword">func</span> <span class="function">main</span>() {
    tree := <span class="function">NewRadixTree</span>()

    <span class="comment">// Insert words</span>
    words := []<span class="keyword">string</span>{<span class="string">"romane"</span>, <span class="string">"romanus"</span>, <span class="string">"romulus"</span>, 
                     <span class="string">"rubens"</span>, <span class="string">"ruber"</span>, <span class="string">"rubicon"</span>}
    
    <span class="keyword">for</span> i, word := <span class="keyword">range</span> words {
        tree.<span class="function">Insert</span>(word, i)
        fmt.<span class="function">Printf</span>(<span class="string">"Inserted: %s\n"</span>, word)
    }

    <span class="comment">// Search for words</span>
    <span class="keyword">if</span> value, found := tree.<span class="function">Search</span>(<span class="string">"romanus"</span>); found {
        fmt.<span class="function">Printf</span>(<span class="string">"Found 'romanus' with value: %v\n"</span>, value)
    }

    <span class="comment">// Find all words with prefix</span>
    results := tree.<span class="function">StartsWith</span>(<span class="string">"rom"</span>)
    fmt.<span class="function">Printf</span>(<span class="string">"Words starting with 'rom': %v\n"</span>, results)

    fmt.<span class="function">Printf</span>(<span class="string">"Total words in tree: %d\n"</span>, tree.<span class="function">Size</span>())
}</code></pre>
                </div>

                <div class="highlight">
                    <h3>Key Features of the Go Implementation:</h3>
                    <p>‚úì Full CRUD operations (Create, Read, Update, Delete)<br>
                    ‚úì Prefix search with StartsWith() method<br>
                    ‚úì Generic value storage using interface{}<br>
                    ‚úì Efficient edge splitting and merging<br>
                    ‚úì Memory-efficient map-based children storage</p>
                </div>
            </div>

            <div class="section">
                <h2>üöÄ Real-World Applications</h2>
                
                <div class="highlight">
                    <h3>1. IP Routing Tables</h3>
                    <p>Radix trees are extensively used in network routers for longest prefix matching in IP routing tables. They efficiently store and lookup network addresses.</p>
                </div>

                <div class="highlight">
                    <h3>2. Memory Management</h3>
                    <p>Linux kernel uses radix trees for memory page management, allowing fast lookup of memory pages by their index.</p>
                </div>

                <div class="highlight">
                    <h3>3. Autocomplete Systems</h3>
                    <p>Search engines and text editors use radix trees to provide fast prefix-based suggestions and autocomplete functionality.</p>
                </div>

                <div class="highlight">
                    <h3>4. Database Indexing</h3>
                    <p>Some databases use radix trees for string-based indexing, especially for variable-length keys.</p>
                </div>

                <div class="highlight">
                    <h3>5. Compressed File Systems</h3>
                    <p>File path storage and lookup in compressed file systems benefit from radix tree's space efficiency.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Simple Radix Tree implementation
        class RadixNode {
            constructor() {
                this.children = new Map();
                this.isEndOfWord = false;
            }
        }

        class RadixTree {
            constructor() {
                this.root = new RadixNode();
            }

            insert(word) {
                this._insertHelper(this.root, word);
            }

            _insertHelper(node, word) {
                if (word.length === 0) {
                    node.isEndOfWord = true;
                    return;
                }

                for (let [edge, child] of node.children) {
                    let commonPrefix = this._getCommonPrefix(edge, word);
                    
                    if (commonPrefix.length > 0) {
                        if (commonPrefix.length === edge.length && commonPrefix.length === word.length) {
                            child.isEndOfWord = true;
                            return;
                        }
                        
                        if (commonPrefix.length === edge.length) {
                            this._insertHelper(child, word.substring(commonPrefix.length));
                            return;
                        }
                        
                        // Split the edge
                        let newNode = new RadixNode();
                        node.children.delete(edge);
                        node.children.set(commonPrefix, newNode);
                        
                        newNode.children.set(edge.substring(commonPrefix.length), child);
                        
                        if (commonPrefix.length < word.length) {
                            let remainingWord = word.substring(commonPrefix.length);
                            newNode.children.set(remainingWord, new RadixNode());
                            newNode.children.get(remainingWord).isEndOfWord = true;
                        } else {
                            newNode.isEndOfWord = true;
                        }
                        return;
                    }
                }

                // No matching edge found, create new
                let newNode = new RadixNode();
                newNode.isEndOfWord = true;
                node.children.set(word, newNode);
            }

            _getCommonPrefix(str1, str2) {
                let i = 0;
                while (i < str1.length && i < str2.length && str1[i] === str2[i]) {
                    i++;
                }
                return str1.substring(0, i);
            }

            search(word) {
                let node = this.root;
                let i = 0;

                while (i < word.length) {
                    let found = false;
                    for (let [edge, child] of node.children) {
                        if (word.substring(i).startsWith(edge)) {
                            i += edge.length;
                            node = child;
                            found = true;
                            break;
                        }
                    }
                    if (!found) return false;
                }
                return node.isEndOfWord;
            }
        }

        let tree = new RadixTree();
        
        // Initial words
        ['romane', 'romanus', 'romulus', 'rubens', 'ruber', 'rubicon', 'rubicundus'].forEach(word => {
            tree.insert(word);
        });

        function addWord() {
            let input = document.getElementById('wordInput');
            let word = input.value.trim().toLowerCase();
            
            if (word) {
                tree.insert(word);
                document.getElementById('output').innerHTML = `<span style="color: #50fa7b;">‚úì Added: "${word}"</span>`;
                input.value = '';
                visualizeTree();
            }
        }

        function searchWord() {
            let input = document.getElementById('wordInput');
            let word = input.value.trim().toLowerCase();
            
            if (word) {
                let found = tree.search(word);
                document.getElementById('output').innerHTML = found ? 
                    `<span style="color: #50fa7b;">‚úì Found: "${word}"</span>` :
                    `<span style="color: #ff5555;">‚úó Not found: "${word}"</span>`;
            }
        }

        function clearTree() {
            tree = new RadixTree();
            document.getElementById('output').innerHTML = '<span style="color: #f1fa8c;">Tree cleared!</span>';
            visualizeTree();
        }

        function visualizeTree() {
            let svg = document.getElementById('interactiveTree');
            svg.innerHTML = '';
            
            let width = 900;
            let height = 500;
            let nodeRadius = 30;
            
            function drawNode(node, x, y, label, isEnd) {
                let circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', x);
                circle.setAttribute('cy', y);
                circle.setAttribute('r', nodeRadius);
                circle.setAttribute('fill', isEnd ? '#667eea' : 'white');
                circle.setAttribute('stroke', '#667eea');
                circle.setAttribute('stroke-width', '3');
                svg.appendChild(circle);

                if (label) {
                    let text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', x);
                    text.setAttribute('y', y + 5);
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('font-size', '14');
                    text.setAttribute('font-weight', 'bold');
                    text.setAttribute('fill', isEnd ? 'white' : '#667eea');
                    text.textContent = label;
                    svg.appendChild(text);
                }
            }

            function drawEdge(x1, y1, x2, y2, label) {
                let line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', x1);
                line.setAttribute('y1', y1);
                line.setAttribute('x2', x2);
                line.setAttribute('y2', y2);
                line.setAttribute('stroke', '#764ba2');
                line.setAttribute('stroke-width', '2');
                svg.appendChild(line);

                if (label) {
                    let text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', (x1 + x2) / 2);
                    text.setAttribute('y', (y1 + y2) / 2 - 5);
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('font-size', '12');
                    text.setAttribute('font-family', 'monospace');
                    text.setAttribute('fill', '#764ba2');
                    text.textContent = label;
                    svg.appendChild(text);
                }
            }

            function traverse(node, x, y, level, index, totalAtLevel) {
                drawNode(node, x, y, level === 0 ? 'root' : '', node.isEndOfWord);

                let children = Array.from(node.children.entries());
                let childSpacing = Math.min(150, width / (totalAtLevel + 1));
                let startX = x - (children.length - 1) * childSpacing / 2;

                children.forEach(([edge, child], i) => {
                    let childX = startX + i * childSpacing;
                    let childY = y + 100;
                    
                    drawEdge(x, y + nodeRadius, childX, childY - nodeRadius, edge);
                    traverse(child, childX, childY, level + 1, i, children.length);
                });
            }

            traverse(tree.root, width / 2, 60, 0, 0, 1);
        }

        // Draw static visualizations
        function drawStaticTrie() {
            let svg = document.getElementById('trieVisualization');
            svg.innerHTML = '';
            
            // Simplified trie representation
            let trieStructure = `
                <text x="400" y="30" text-anchor="middle" font-size="14" fill="#666">Root</text>
                <circle cx="400" cy="50" r="20" fill="white" stroke="#667eea" stroke-width="2"/>
                
                <line x1="400" y1="70" x2="200" y2="130" stroke="#764ba2" stroke-width="2"/>
                <text x="300" y="100" text-anchor="middle" font-size="12" fill="#764ba2">t</text>
                <circle cx="200" cy="150" r="20" fill="white" stroke="#667eea" stroke-width="2"/>
                
                <line x1="400" y1="70" x2="600" y2="130" stroke="#764ba2" stroke-width="2"/>
                <text x="500" y="100" text-anchor="middle" font-size="12" fill="#764ba2">s</text>
                <circle cx="600" cy="150" r="20" fill="white" stroke="#667eea" stroke-width="2"/>
                
                <text x="400" y="250" text-anchor="middle" font-size="14" fill="#666" font-style="italic">
                    Many nodes for each character...
                </text>
            `;
            svg.innerHTML = trieStructure;
        }

        function drawStaticRadix() {
            let svg = document.getElementById('radixVisualization');
            svg.innerHTML = '';
            
            let radixStructure = `
                <text x="400" y="30" text-anchor="middle" font-size="14" fill="#666">Root</text>
                <circle cx="400" cy="50" r="20" fill="white" stroke="#667eea" stroke-width="2"/>
                
                <line x1="400" y1="70" x2="250" y2="130" stroke="#764ba2" stroke-width="2"/>
                <text x="325" y="100" text-anchor="middle" font-size="12" fill="#764ba2" font-weight="bold">test</text>
                <circle cx="250" cy="150" r="20" fill="#667eea" stroke="#667eea" stroke-width="2"/>
                
                <line x1="400" y1="70" x2="400" y2="130" stroke="#764ba2" stroke-width="2"/>
                <text x="400" y="100" text-anchor="middle" font-size="12" fill="#764ba2" font-weight="bold">toast</text>
                <circle cx="400" cy="150" r="20" fill="white" stroke="#667eea" stroke-width="2"/>
                
                <line x1="400" y1="70" x2="550" y2="130" stroke="#764ba2" stroke-width="2"/>
                <text x="475" y="100" text-anchor="middle" font-size="12" fill="#764ba2" font-weight="bold">slow</text>
                <circle cx="550" cy="150" r="20" fill="white" stroke="#667eea" stroke-width="2"/>
                
                <text x="400" y="250" text-anchor="middle" font-size="14" fill="#666" font-style="italic">
                    Compressed paths - fewer nodes!
                </text>
            `;
            svg.innerHTML = radixStructure;
        }

        // Initialize static visualizations
        drawStaticTrie();
        drawStaticRadix();
        visualizeTree();

        // Allow Enter key to add words
        document.getElementById('wordInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                addWord();
            }
        });
    </script>
</body>
</html>
